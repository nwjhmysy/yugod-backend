### 1.vue3-vite-ts

配置文件：

- vite.config.ts

  ```tsx
  /// <reference types="vitest" />
  
  import { defineConfig } from 'vite';
  import vue from '@vitejs/plugin-vue';
  import { resolve } from 'path';
  
  // https://vitejs.dev/config/
  export default defineConfig({
    plugins: [vue()],
    test: {
      globals: true,
      environment: 'jsdom',
    },
    resolve: {
      alias: [
        {
          find: /^@\//,
          replacement: `${resolve(__dirname, 'src')}/`,
        },
      ],
    },
    server: {
      port: 8848,
    },
  });
  ```

- tsconfig.node.json

  在前端项目中，`tsconfig.node.json` 文件通常用于配置 TypeScript 编译器（tsc）的选项，以适应 Node.js 环境的特定需求。这个配置文件是 TypeScript 项目的一部分，用于指导 TypeScript 编译器如何处理 TypeScript 代码并生成 JavaScript 代码。

  ```json
  {
    "compilerOptions": {
      "composite": true,
      "skipLibCheck": true,
      "module": "ESNext",
      "moduleResolution": "bundler",
      "allowSyntheticDefaultImports": true
    },
    "include": ["vite.config.ts"]
  }
  ```

- tsconfig.json

  ```json
  {
    "compilerOptions": {
      "target": "ES2020",
      "useDefineForClassFields": true,
      "module": "ESNext",
      "lib": ["ES2020", "DOM", "DOM.Iterable"],
      "skipLibCheck": true,
  
      /* Bundler mode */
      "moduleResolution": "bundler",
      "allowImportingTsExtensions": true,
      "resolveJsonModule": true,
      "isolatedModules": true,
      "noEmit": true,
      "jsx": "preserve",
  
      /* Linting */
      "strict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noFallthroughCasesInSwitch": true,
  
      "baseUrl": ".",
      "paths": {
        "@/*": [
          "src/*"
        ]
      },
    },
    "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
    "references": [{ "path": "./tsconfig.node.json" }]
  }
  ```

  

### 2.vue-tsc

Install: `npm i vue-tsc -D`

Vue-tsc 是Vue 框架的TypeScript 版本，它为Vue 提供了TypeScript 支持。 TypeScript 是一种强类型语言，可以让开发人员更容易地编写代码，并在编译时发现错误。 使用Vue-tsc 可以帮助开发人员更好地组织代码，并减少因为类型错误而导致的问题。

### 3.vitest

前端测试库

```
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:ci": "vitest run",
    "test:watch": "vitest watch",
    "test:cov": "vitest run --coverage",
```



### 4.normalize.css（不需引入）

全局css样式的一种规范

https://github.com/necolas/normalize.css?tab=readme-ov-file

### 5.autoprefixer

css自动前缀

作用：对一些css属性自动添加前缀。因为 css 中有一些属性还没有确定下来，标准规范还没有发布，许多浏览器支持的程度也不同，而且每个浏览器厂商同一个样式支持的写法也不同，所以要加前缀来达到各个浏览器兼容，将来统一了规范就不用写前缀了。

### 6.prettier

格式化代码

配置文件：

- .prettier

  ```
  {
    "semi": true,
    "singleQuote": true,
    "tabWidth": 2,
    "printWidth": 120
  }
  ```

- .prettierignore

  不对文件中列出的目录格式化

  ```
  src/services/*
  src/stories/*
  ```

### 7.husky

通过git推送代码时提供一些验证，代码格式化等操作。

如：pre-push

```sh
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

npm run tsc
npm run format
npm run test:ci
```

### 8.tailwindcss

类式css

配置：

- style.css

  ```css
  /* @tailwind base; */
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
  // ------------- 自定义全局类名 -------------
  .custom-link {
    text-decoration: none; /* 去除下划线 */
    color: inherit; /* 继承父元素的文字颜色 */
  }
  
  .custom-li {
    list-style: none;
    display: inline-block;
  }
  
  .required-label::before {
    @apply text-alert-error-text text-sm;
    content: '*';
    margin-inline-end: 4px;
  }
  
  .input-label::after {
    @apply text-black text-sm;
    content: '：';
    margin-inline-end: 4px;
  }
  
  .flex-center {
    @apply flex justify-center items-center;
  }
  
  .inline-flex-center {
    @apply inline-flex justify-center items-center;
  }
  
  .custom-input-border {
    @apply border rounded-md border-grey;
  }
  
  .custom-input-border:not(.disable-status):hover,
  .custom-input-border:not(.disable-status):focus {
    @apply border-blue-hover shadow-input-active;
  }
  
  .custom-input-border.error-status {
    @apply border-error;
  }
  
  .custom-input-border.error-status:hover {
    @apply shadow-input-error;
  }
  ```

- tailwind.config.js

  ```js
  /** @type {import('tailwindcss').Config} */
  export default {
    content: ['./src/**/*.{html,js,ts,vue}'],
    theme: {
      extend: {},
      colors: {
        'font-primary': '#1990FF',
        'btn-primary': '#1890FF',
        'point-green': '#52C41A',
        error: '#F5222D',
        grey: '#D9D9D9',
        white: '#FFFFFF',
        black: '#222222',
        blue: {
          header: '#001529',
          'header-hover': '#252A3D',
          active: '#1677ff',
          hover: '#4096ff',
        },
        gray: {
          bg: '#F5F5F5',
          text: 'rgb(255 255 255 / 65%)',
          breadcrumb: {
            light: 'rgb(0 0 0 / 45%)',
            deep: 'rgb(0 0 0 / 65%)',
          },
          disabled: {
            border: '#D9D9D9',
            text: 'rgba(0, 0, 0, 0.25)',
            bg: 'rgba(0, 0, 0, 0.04)',
          },
        },
        info: {
          text: '#1677ff',
          bg: '#e6f4ff',
          border: '#91caff',
        },
        warning: {
          text: '#faad14',
          bg: '#fffbe6',
          border: '#ffe58f',
        },
        success: {
          text: '#52c41a',
          bg: '#f6ffed',
          border: '#b7eb8f',
        },
        'alert-error': {
          text: '#ff4d4f',
          bg: '#fff2f0',
          border: '#ffccc7',
        },
      },
      boxShadow: {
        'picker-panel':
          '0 6px 16px 0 rgba(0, 0, 0, 0.08),0 3px 6px -4px rgba(0, 0, 0, 0.12),0 9px 28px 8px rgba(0, 0, 0, 0.05);',
        'input-active': '0 0 0 2px rgba(5, 145, 255, 0.1);',
        'input-error': '0 0 0 2px rgba(255, 38, 5, 0.06);',
      },
      minWidth: {
        screen: '768px',
      },
    },
    plugins: [],
  };
  
  ```

### 9.`.env`（不需引入）

提供环境变量。

例如：

```
VITE_API_BATH_PATH='http://docker.fenrir-inc.cn:8849/api'
```

获取：

```ts
const basePath = import.meta.env.VITE_API_BATH_PATH;
```

### 10.打包并导入nginx服务器镜像

- **根据基础镜像定义镜像**

  `Dockerfile`

  ```dockerfile
  # 基于 Node 镜像构建 Vite 项目
  FROM node:18.18.2-alpine AS builder
  
  WORKDIR /app
  
  COPY package.json .
  COPY package-lock.json .
  
  # 这个命令是用来配置 npm（Node Package Manager）的注册表（registry）地址的。
  # npm 注册表是一个存储和分发 Node.js 包的中央存储库。
  # 通过设置注册表地址，你可以指定 npm 在哪里查找和下载软件包。
  RUN npm config set registry https://registry.npmjs.org
  RUN npm install
  
  COPY . .
  RUN npm run build:dev
  
  # 构建 Nginx 服务器并拷贝 Vite 项目的构建文件
  FROM nginx:alpine
  
  COPY --from=builder /app/dist /usr/share/nginx/html
  COPY nginx.conf /etc/nginx/nginx.conf
  
  
  EXPOSE 80
  
  CMD ["nginx", "-g", "daemon off;"]
  ```

  注意：`FROM`指令标志着一个新的构建阶段的开始，而Docker支持多阶段构建。在多阶段构建中，可以使用多个`FROM`指令来创建不同的镜像阶段，并在最终阶段中选择性地复制之前阶段构建的结果。这有助于减小最终镜像的大小，只包含必要的文件和依赖项。

- **构建镜像**

  ```
  docker build --platform=linux/amd64 -t ＜image_name＞ .
  ```

  1. `docker build`: 这是构建Docker镜像的命令。
  2. `--platform=linux/amd64`: 这个选项指定了要构建的镜像的目标平台。在这里，它指定了镜像将在`linux/amd64`平台上运行。这可以用于多平台构建，以确保生成的镜像可以在指定的平台上运行。
  3. `-t ＜image_name＞`: 这是为构建的镜像指定一个标签（tag）的选项。`-t`用于设置镜像的标签，`＜image_name＞`是标签的名称，这个名称通常包括了仓库地址、镜像名称和版本号。

  因此，整个命令的目的是在`linux/amd64`平台上构建一个名为`＜image_name＞`的Docker镜像。

- **将docker镜像推送到容器注册表**

  先登录

  ```
  docker login <registry-url>
  ```

  将你的**Docker镜像**推送到一个容器注册表，如Docker Hub、Google Container Registry、Amazon Elastic Container Registry (ECR)等。这通常需要你在注册表上创建一个帐户，并在本地登录到该帐户。

  ```
  docker push <image>
  ```

之后就可以使用安装了docker的云服务器拉取镜像并运行。