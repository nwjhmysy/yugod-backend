### 一.`computed`和 `watch`的区别

#### 1.`computer`的特点与优点

```
特点：
1）支持缓存，只有依赖数据发生改变，才会重新进行计算；
2）不支持异步，当 computed 内有异步操作时无效，无法监听数据的变化；
3）computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的。也就是基于 data 中声明过或者父组件传递的 props 中的数据通过计算得到的值；
4）如果一个属性是由其他属性计算而来的，这个属性依赖其他属性 是一个多对一或者一对一，一般用computed；
5）如果 computed 属性值是函数，那么默认会走 get 方法，函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个 set 方法，当数据变化时，调用 set 方法；

优点:
1）当改变 data 变量值时，整个应用会重新渲染，vue 会被数据重新渲染到 dom 中。这时，如果我们使用 names ，随着渲染，方法也会被调用，而 computed 不会重新进行计算，从而性能开销比较小。当新的值需要大量计算才能得到，缓存的意义就非常大；
2）如果 computed 所依赖的数据发生改变时，计算属性才会重新计算，并进行缓存；当改变其他数据时，computed 属性 并不会重新计算，从而提升性能；
3）当拿到的值需要进行一定处理使用时，就可以使用 computed；
```

#### 2.`watch`的特点与优点

```
特点：

1）不支持缓存，数据变化，直接会触发相应的操作；
2）watch 支持异步操作；
3）监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；
4）当一个属性发生变化时，需要执行对应的操作，一对多；
5）监听数据必须是 data 中声明过或者父组件传递过来的 props 中的数据。当数据变化时触发其他操作，函数有两个参数：
immediate：组件加载立即触发回调函数执行；
deep: 深度监听；为了发现对象内部值的变化，复杂类型的数据时使用
注意1：监听数组的变动不需要这么做。
注意2：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到；
```

注：当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的，这是和 `computed` 最大的区别。

#### 3.`watch`监听复杂数据时（`data`中的对象的某一属性）

```javascript
不使用 deep 时，当我们改变 obj.a 的值时，watch 不能监听到数据变化，默认情况下，handler 只监听属性引用的变化，也就是只监听了一层，但改对象内部的属性是监听不到的。

实现方法：
<template>
  <div>
    <el-input v-model="obj.text"></el-input>
  </div>
</template>

<script>
export default {
  data() {
    return {
      obj:{
        text:'hello',
      }
    };
  },
  watch:{
    // 监听对象单个属性text
    'obj.text':{
      handler (newVal,oldval) {
        console.log(newVal,oldval)
      },
      immediate: true, // 该属性会先执行一次handler
    }
  },
};
</script>
```

#### 注意事项

```
1）watch 中的函数名称必须是所依赖 data 中的属性名称；

2）watch 中的函数是不需要调用的，只要函数所依赖的属性发生了改变 那么相对应的函数就会执行；

3）watch 中的函数会有2个参数 一个是新值，一个是旧值；

4）watch 默认情况下无法监听对象的改变，如果需要进行监听则需要进行深度监听 深度监听需要配置 handler 函数以   及 deep 为true。(因为它只会监听对象的地址是否发生了改变，而值是不会监听的)；

5）watch 默认情况下第一次的时候不会去做监听，如果需要在第一次加载的时候也需要去做监听的话需要设置 immediate:true；

6）watch 在特殊情况下是无法监听到数组的变化：
通过下标来更改数组中的数据；
通过 length 来改变数组的长度；

7）深度监听对应的函数名必须为 handler ,否则无效果,因为 watcher里面对应的是对 handler 的调用
```

